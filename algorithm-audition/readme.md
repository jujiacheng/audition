# algorithm

## 数据结构

- 计算机存储，组织数据的方式

## 时间复杂度

- 一个函数，定性描述该算法的运行时间

## 空间复杂度

- 一个函数，算法在运行过程中临时占用存储空间大小的度量

## 栈

### 什么是栈

- 一个后进先出(先进后出)的数据结构
- js 中没有栈，但可以用 Array 实现栈的所有功能(push--入栈; pop--出栈)

### 使用场景

- 所有需要后进先出的场景: 十进制转二进制，判断字符串中的括号是否有效，函数调用堆栈

### 前端与栈：JS 中的函数调用堆栈

- 断点调试 callStack.js

## 队列

- 一个先进先出的数据结构
- js 中没有队列，但可以使用 Array 实现队列所有功能

### 使用场景

- 所有需要先进先出的场景，js 异步中的任务队列，计算最近请求的次数

## 链表

- 多个元素组成的列表。
- 元素存储不连续，用 next 指针连在一起。
- 与数组的区别：数组增删非首尾元素时往往需要易懂元素；而链表增删非收尾元素，不需要移动元素，只需要更改 next 的指向即可。
- js 中没有链表，可以用 Object 模拟链表

### js 中的原型链

- 原型链本质是链表
- 原型链上的节点是各种原型对象，比如：Function.prototype、Object.prototype...
- 原型链通过`__proto__`属性连接各种原型对象

### 原型链知识点

- 如果 A 沿着原型链能找到 B.prototype，那么 `A instanceof B` 为 true
- 如果 A 对象上没有 x 属性，则会沿着原型链往上找

## 集合

- 一种无序且唯一的数据结构
- ES6 中有集合，名为 Set
- 集合的常用操作：去重、判断元素是否在集合中，求交集

## 字典

- 与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储
- es6 中有字典，Map
- 字典的常用操作：健值对的增删改查

## 树

- 一种分层数据的抽象模型
- 前端常见的树：DOM 树，级联选择，树形控件
- js 中没有树，可以通过 Object 和 Array 构建树

```(js)
{
  label: 'a',
  value: 'aaa',
  children: [
    {
      label: 'a-a',
      value: 'a-aaa'
    }
  ]
}
```

### 常用操作

- 深度/广度优先遍历；对于二叉树还是有先中后序遍历

#### 深度优先遍历

- 尽可能深的搜索树的分支
  1. 访问根节点
  2. 对根节点的 children 挨个进行深度优先遍历

#### 广度优先遍历

- 先访问离根节点近的节点
  1. 新建一个队列，把根节点入队
  2. 把队头出队并访问
  3. 把队头的 children 挨个入队。
  4. 重复第二，第三步知道队列为空

### 二叉树

- 树中每个节点最多只能有两个字节点
- 在 js 中通常用 Object 来模拟二叉树

#### 先序遍历口诀

1. 访问根节点
2. 对根节点的左子树进行先序遍历
3. 对根节点的右子树进行先序遍历

#### 中序遍历口诀

1. 对根节点的左子树进行中序遍历
2. 访问根节点
3. 对根节点的右子树进行中序遍历

#### 后序遍历口诀

1. 对根节点的左子树进行后序遍历
2. 对根节点的右子树进行后序遍历
3. 访问根节点

## 图

- 图是网络结构的抽象模型，是一组由边连接的节点
- 图可以表示任何二元关系，比如道路航班。。。
- js 中没有图，但是可以用 Object 和 Array 构建图
- 图的表示法：临接矩阵、临接表、关联矩阵。。。

### 常用操作

- 深度优先遍历：尽可能深的搜索图的分支
  1. 访问根节点。
  2. 对根节点的没有访问过的相邻节点挨个进行深度优先遍历。
- 广度优先遍历：现访问离根节点最近的节点。

  1. 新建一个队列，把根节点入队。
  2. 把队头出队并访问。
  3. 把队头的每访问过的相邻节点入队。
  4. 重复 2，3 直到队列为空

  ## 堆

- 堆是一种特殊的完全二叉树
- 所有的节点都大于等于（最大堆）或小于等于（最小堆）他的字节点
- js 中通常用数组表示堆
- 左侧字节点的位置是 2\*index+1
- 右侧字节点的位置是 2\* index+2
- 父节点位置是(index-1)/2
- 快速高效的找出最大值和最小值：时间复杂度:O(1)
- 找出第 k 个最大最小值
